# Vasion Project AI Rules

This project uses Tailwind CSS (migrating from styled-components). Follow these rules for ALL code changes.

## Critical Rules

1. **PRESERVE ORIGINAL LAYOUT** - Converted components must look IDENTICAL to the original
2. **ALWAYS use Tailwind CSS** - Never use styled-components for new code
3. **NO arbitrary px values** - No `w-[450px]`, use rem or closest Tailwind value
4. **ALWAYS use design tokens** - Reference `tailwind.config.js` for colors, typography, spacing
5. **ALWAYS ensure ADA compliance** - Alt text, focus states, semantic HTML
6. **ALWAYS use the `cn()` utility** - Import from `@/lib/cn` for conditional classes

## Converting VW to Tailwind

**Key Insight**: Different vw values per breakpoint = SAME pixel target → ONE Tailwind class

| Target | Desktop (1600px) | Tablet (1024px) | Mobile (480px) | Tailwind |
|--------|------------------|-----------------|----------------|----------|
| 200px | `12.5vw` | `19.531vw` | `41.667vw` | `w-50` |
| 100px | `6.25vw` | `9.766vw` | `20.833vw` | `w-25` |
| 80px | `5vw` | `7.813vw` | `16.667vw` | `w-20` |

**Formula**: `px = vw × (viewportWidth / 100)` then `rem = px / 16`

## PX to Tailwind Class

**Tailwind JIT generates any number automatically using**: `number × 0.25rem = size`

**To convert px to Tailwind class**: `px / 4 = Tailwind number`

Examples:
- 1304px / 4 = 326 → `w-326` (auto-generates 81.5rem)
- 1236px / 4 = 309 → `max-w-309` (auto-generates 77.25rem)
- 200px / 4 = 50 → `w-50`
- 100px / 4 = 25 → `w-25`

**DO NOT add custom values to tailwind.config.js** - Tailwind JIT handles it automatically.

```typescript
import { vwToRem, detectBreakpoint } from '@/lib/tailwind-utils';
```

## Quick Reference

### Imports to Use
```jsx
import { cn } from '@/lib/cn';
import { cva, type VariantProps } from '@/lib/cva';
import Image from 'next/image';
```

### Breakpoints
- `mob:` (max-480px)
- `tab:` (481-1024px)
- `desk:` (1025-1600px)
- `fw:` (1601px+)

### Common Colors
- Purple: `purple-DEFAULT`, `purple-dark`, `purple-light`, `purple-border`
- Orange: `orange-DEFAULT`, `orange-500`
- Teal: `teal-DEFAULT`, `teal-500`
- Grey: `grey-800` to `grey-25`
- Text: `txt-primary`, `txt-subtle`

### Typography
- Headings: `text-h1` through `text-h5`
- Body: `text-body-xl`, `text-body-lg`, `text-body-md`, `text-body-sm`
- Special: `text-eyebrow`, `text-tag`, `text-subtle`
- Font: `font-archivo`, `font-orbitron`

### Gradients
- `bg-purple-orbital`, `bg-purple-gradient`, `bg-orange-gradient`
- `bg-light-purple`, `bg-dark-purple`, `bg-medium-purple`

## Component Template (Simple)

```jsx
// Only add 'use client' if needed for hooks/interactivity
'use client';

import { useState } from 'react';

import Image from 'next/image';

import { cn } from '@/lib/cn';

export default function ComponentName({ variant = 'default', className }) {
  return (
    <div 
      className={cn(
        // Base styles
        'flex flex-col gap-4 p-6',
        // Responsive styles
        'tab:flex-row tab:gap-6 tab:p-8',
        'desk:gap-8 desk:p-12',
        // Variant styles
        variant === 'primary' && 'bg-purple-DEFAULT text-white',
        variant === 'secondary' && 'bg-grey-25 text-txt-primary',
        // Allow className override
        className
      )}
    >
      {/* Content with proper accessibility */}
      <Image 
        src="/image.webp"
        alt="Descriptive alt text"
        width={400}
        height={300}
        className="rounded-lg"
      />
      <button
        className="px-4 py-2 bg-orange-DEFAULT text-white rounded-md
          hover:bg-orange-dark transition-colors
          focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2"
      >
        Button Text
      </button>
    </div>
  );
}
```

## Component Template (With CVA Variants)

```jsx
import { cva, type VariantProps } from '@/lib/cva';
import { cn } from '@/lib/cn';

const cardVariants = cva(
  'rounded-lg p-6 transition-shadow', // base styles
  {
    variants: {
      variant: {
        default: 'bg-white shadow-md',
        elevated: 'bg-white shadow-lg hover:shadow-xl',
        outlined: 'bg-transparent border border-grey-200',
      },
      size: {
        sm: 'p-4',
        md: 'p-6',
        lg: 'p-8 tab:p-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'md',
    },
  }
);

type CardProps = VariantProps<typeof cardVariants> & {
  className?: string;
  children: React.ReactNode;
};

export default function Card({ variant, size, className, children }: CardProps) {
  return (
    <div className={cn(cardVariants({ variant, size }), className)}>
      {children}
    </div>
  );
}
```

## Converting styled-components

When asked to convert a file:
1. Remove `import styled from 'styled-components'`
2. Replace `styled.div` with `<div className="...">`
3. Convert props-based styles to `cn()` conditionals
4. Map `${media.mobile}` to `mob:`, `${media.tablet}` to `tab:`, `${media.desktop}` to `desk:`, `${media.fullWidth}` to `fw:`
5. Map `${colors.X}` to `text-X` or `bg-X`
6. Map `${text.X}` to `text-X font-archivo`
7. Add focus states to interactive elements
8. Ensure all images have alt text
9. Check heading hierarchy (h1 > h2 > h3)

## Server Components (CRITICAL for Performance)

**Always prefer Server Components** - only use `'use client'` when absolutely necessary.

### When to Use Server Components
- Static content rendering
- Data fetching
- Components that don't need interactivity
- Layout containers and wrappers

### When Client Components Are Required
- React hooks (`useState`, `useEffect`, `useContext`)
- Browser APIs (`window`, `document`)
- Event handlers that modify state
- Third-party libraries requiring client-side execution (GSAP, etc.)

### Extracting Client Logic Pattern

When a component needs GSAP or other client-only features, extract them:

```jsx
// ServerComponent.js (NO 'use client')
import CarouselAnimator from './CarouselAnimator';

const ServerComponent = ({ blok }) => {
  const shouldAnimate = blok.logos?.length > 5;
  
  return (
    <>
      {/* Static content renders server-side */}
      <div className="carousel">
        {blok.logos?.map((logo) => (
          <div className="carousel-item" key={logo.id}>...</div>
        ))}
      </div>
      
      {/* Minimal client component for animation only */}
      {shouldAnimate && <CarouselAnimator selector=".carousel-item" />}
    </>
  );
};
```

### Scoped CSS for Responsive Styles (Server Components)

Use inline `<style>` tags with unique IDs for responsive styles without client JS:

```jsx
const ServerComponent = ({ blok }) => {
  const componentId = `component-${blok._uid}`;
  
  return (
    <>
      <style>{`
        .${componentId} {
          padding: 3.75rem;
          max-width: 81.5rem;
        }
        @media (max-width: 1024px) {
          .${componentId} { padding: 2.5rem; }
        }
        @media (max-width: 480px) {
          .${componentId} { padding: 1.75rem 1.125rem; }
        }
      `}</style>
      <div className={componentId}>...</div>
    </>
  );
};
```

### Reusable Client Components

Use `CarouselAnimator` for any horizontal loop animation:

```jsx
import CarouselAnimator from '@/components/CarouselAnimator';

// Basic usage
<CarouselAnimator selector=".my-items" />

// With options
<CarouselAnimator 
  selector=".logo-items"
  options={{ speed: 0.5, reversed: true, draggable: true }}
/>
```

## CRITICAL: Inline Styles Fallback

**Tailwind classes may not be applied** due to JIT compilation issues. When layout-critical styles aren't working:

1. **Use ScreenContext for responsive styles** instead of Tailwind breakpoint prefixes:
```jsx
import { useContext } from 'react';
import { ScreenContext } from '@/components/providers/Screen';

const screen = useContext(ScreenContext);

const getResponsiveStyle = () => {
  if (screen.mobile) {
    return { padding: '2.8rem 1.8rem', borderRadius: '1.7rem' };
  } else if (screen.tablet) {
    return { padding: '2.5rem', borderRadius: '1.5rem' };
  }
  return { padding: '3.75rem', maxWidth: '81.5rem', borderRadius: '1.5rem' };
};
```

2. **Apply critical layout styles inline**:
```jsx
<div style={getResponsiveStyle()}>
```

3. **Always add to lists**:
```jsx
<ul style={{ listStyle: 'none', margin: 0, padding: 0 }}>
  <li style={{ listStyle: 'none' }}>
```

## Before Converting: Ask for Figma Reference

**ALWAYS ask before converting a component:**
> "Do you have a Figma link for this component? I can use it to ensure pixel-perfect implementation."

If a Figma link is provided:
1. Use the Figma MCP tools to fetch design specs
2. Extract exact colors, spacing, typography, and dimensions
3. Verify converted component matches design precisely

## Conversion Checklist

When converting a styled-component:

1. **Evaluate for Server Component** - Can it work WITHOUT `'use client'`?
   - If yes: Use scoped `<style>` tags for responsive styles, import themes statically
   - If client code needed (GSAP): Extract to minimal client component like `CarouselAnimator`
2. **Preserve EXACT structure** - Same number of containers, same nesting
3. **Handle ALL props** - Check original for props like:
   - `transparent_background` → affects width, padding, background
   - `offset_spacing` → affects vertical padding (top/bottom/both)
   - `section_spacing` → custom pixel spacing value
4. **Match values per breakpoint** - Calculate original vw → px → rem for EACH breakpoint
5. **Use appropriate responsive approach**:
   - Server Component: `<style>` tag with `@media` queries
   - Client Component: `ScreenContext` for reliable responsive styles
6. **Test ALL breakpoints** - Desktop, tablet, mobile must match original
7. **Check outer wrapper** - Most components have section padding for spacing between components
8. **Remove `'use client'`** - After extracting client logic, verify main component is server-side

## Validation

After making changes, remind user to run:
```bash
npm run checks
```

See detailed rules in:
- `.cursor/rules/tailwind-migration.mdc`
- `.cursor/rules/design-tokens.mdc`
- `docs/TAILWIND_MIGRATION.md`
