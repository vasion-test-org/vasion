---
description: Guidelines for Tailwind CSS v4 migration and maintaining code quality standards
globs: ["**/*.{js,jsx,ts,tsx}"]
alwaysApply: true
---

# Tailwind CSS v4 Migration Guidelines

This project uses **Tailwind CSS v4** with CSS-based configuration. We are migrating from styled-components for improved performance. Follow these rules when creating or modifying components.

## Tailwind v4 Configuration

Design tokens are defined in `app/globals.css` using the `@theme` directive:

```css
@import "tailwindcss";

@theme {
  --color-purple: #3D2562;
  --color-orange: #ff5100;
  --spacing-15: 3.75rem;
  --breakpoint-mob: 480px;
  /* All custom values defined here */
}
```

**Key v4 differences:**
- Use `@import "tailwindcss"` (not `@tailwind base/components/utilities`)
- Define custom values in `@theme` block (not `tailwind.config.js`)
- Colors use `--color-*`, spacing uses `--spacing-*`, breakpoints use `--breakpoint-*`

## CRITICAL: Preserve Original Layout

When converting styled-components to Tailwind:
- **PRESERVE THE EXACT VISUAL LAYOUT** - The converted component must look identical
- **DO NOT ADJUST SPACING, SIZING, OR POSITIONING** unless explicitly asked
- Match the original values as closely as possible using Tailwind utilities
- If an exact match isn't possible, use the CLOSEST Tailwind value

## Converting VW Values

Based on [pxvwconverter](https://github.com/RJWadley/pxvwconverter) - the **same pixel value** requires **different vw values** at each breakpoint.

### Key Insight
When styled-components use different vw values per breakpoint, they're targeting the **same pixel size**:

| Target | Desktop (1600px) | Tablet (1024px) | Mobile (480px) | Tailwind |
|--------|------------------|-----------------|----------------|----------|
| 200px | `12.5vw` | `19.531vw` | `41.667vw` | `w-50` |
| 100px | `6.25vw` | `9.766vw` | `20.833vw` | `w-25` |
| 80px | `5vw` | `7.813vw` | `16.667vw` | `w-20` |
| 40px | `2.5vw` | `3.906vw` | `8.333vw` | `w-10` |

### Conversion Formula
```
px = vw × (viewportWidth / 100)
rem = px / 16
```

### How to Convert
1. **Identify the breakpoint** from the media query context
2. **Calculate px** using that breakpoint's viewport width
3. **Convert to rem** (px / 16)
4. **Find closest Tailwind** value

### Example: Converting styled-components
```jsx
// Original:
const Box = styled.div`
  width: 12.5vw; // Desktop (1600px): 12.5 × 16 = 200px = 12.5rem
  ${media.tablet} {
    width: 19.531vw; // Tablet (1024px): 19.531 × 10.24 = 200px = 12.5rem
  }
  ${media.mobile} {
    width: 41.667vw; // Mobile (480px): 41.667 × 4.8 = 200px = 12.5rem
  }
`;

// Converted: All breakpoints produce 200px, so use ONE Tailwind class:
<div className="w-50" /> // 12.5rem = 200px at all breakpoints
```

### Use Conversion Utility
```typescript
import { vwToRem, vwToPx, detectBreakpoint } from '@/lib/tailwind-utils';

// Convert vw at specific breakpoint
vwToRem(12.5, 1600) // Desktop: 12.5rem (200px)
vwToRem(19.531, 1024) // Tablet: 12.5rem (200px)
vwToRem(41.667, 480) // Mobile: 12.5rem (200px)

// All produce same result → use w-50
```

---

## Styling Rules

### Use Tailwind Utility Classes
- **NEVER** use arbitrary values like `w-[450px]`, `h-[200px]`, or `w-[9.5rem]`
- **ALWAYS** convert px to Tailwind number: `px / 4 = Tailwind class`
- Tailwind JIT auto-generates any number (e.g., `w-326` = 326 × 0.25rem = 1304px)
- Custom design tokens are defined in `@theme` block in `app/globals.css`

### PX to Tailwind Conversion
```
px / 4 = Tailwind number
```
Examples:
- 1304px → `w-326` (1304 / 4 = 326)
- 200px → `w-50` (200 / 4 = 50)
- 100px → `w-25` (100 / 4 = 25)
- 24px → `p-6` (24 / 4 = 6)

### Responsive Design
- Use project breakpoint prefixes: `mob:`, `tab:`, `desk:`, `fw:`
- Mobile-first is preferred: write base styles, then add larger breakpoint overrides
- Example: `text-body-sm tab:text-body-md desk:text-body-lg`

### Design Tokens
- Use colors from the config: `text-purple`, `bg-teal-500`, etc. (DEFAULT accessed without suffix)
- Use typography classes: `text-h1`, `text-body-lg`, `text-eyebrow`
- Use spacing tokens: `p-4`, `gap-6`, `m-8` (avoid arbitrary values)

### Conditional Classes
- Use the `cn()` utility from `@/lib/cn` for conditional class merging
- Import: `import { cn } from '@/lib/cn'`
- Example: `className={cn('base-classes', condition && 'conditional-class')}`

### Component Variants (CVA)
- Use `cva()` from `@/lib/cva` for components with multiple variant dimensions
- Import: `import { cva, type VariantProps } from '@/lib/cva'`
- Use CVA when a component has multiple props that affect styling (size, color, state)
- Combine with cn() for className overrides: `cn(variants({ size }), className)`

### Gradients
- Use CSS custom property backgrounds: `bg-purple-gradient`, `bg-orange-gradient`
- Available gradients: `purple-orbital`, `purple-gradient`, `orange-gradient`, `grey-gradient`, `light-purple`, `dark-purple`, `medium-purple`

---

## Performance Rules

### Server vs Client Components (CRITICAL)

**Server Components are the default and preferred choice** for performance.

#### Benefits of Server Components
- Zero client-side JavaScript for static content
- Faster initial page load
- Better SEO (content available immediately)
- Reduced bundle size

#### When to Use Server Components (Default)
- Rendering static content
- Displaying data from CMS (Storyblok)
- Layout containers and wrappers
- Components without interactivity

#### When Client Components Are Required
- React hooks: `useState`, `useEffect`, `useContext`, `useRef`
- Browser APIs: `window`, `document`, `localStorage`
- Event handlers that modify component state
- Third-party client libraries: GSAP, Swiper, etc.

### Extracting Client Logic Pattern

**ALWAYS extract client-only code into minimal client components**:

```jsx
// MyComponent.js - Server Component (NO 'use client')
import Image from 'next/image';
import CarouselAnimator from '@/components/CarouselAnimator';
import { defaultTheme, darkTheme, lightTheme } from '@/styles/theme';

// Static theme lookup - no hooks needed
const themes = { default: defaultTheme, dark: darkTheme, light: lightTheme };

const MyComponent = ({ blok }) => {
  const theme = themes[blok.theme] || themes.default;
  const shouldAnimate = blok.items?.length > 5;
  
  return (
    <>
      {/* All static content renders on server */}
      <section style={{ background: theme.myComponent.bg }}>
        <ul className="item-list">
          {blok.items?.map((item) => (
            <li key={item._uid} className="item">
              <Image src={item.image.filename} alt={item.alt} />
            </li>
          ))}
        </ul>
      </section>
      
      {/* Minimal client component - animation only */}
      {shouldAnimate && <CarouselAnimator selector=".item" />}
    </>
  );
};

export default MyComponent;
```

### Reusable CarouselAnimator

Use `CarouselAnimator` for any horizontal loop animation instead of creating new client components:

```jsx
import CarouselAnimator from '@/components/CarouselAnimator';

// Basic infinite scroll
<CarouselAnimator selector=".logo-item" />

// With custom options
<CarouselAnimator 
  selector=".testimonial-card"
  options={{
    speed: 0.5,        // Slower animation
    reversed: true,    // Right to left
    draggable: true,   // Enable drag
    paused: true,      // Start paused
  }}
  onChange={(el, index) => console.log('Active:', index)}
/>
```

### Styling Performance
- **NEVER use inline styles** - use Tailwind classes exclusively
- **NEVER use scoped `<style>` tags** - use Tailwind breakpoint prefixes
- Do not import styled-components in new code
- Use Tailwind's built-in transitions: `transition-colors`, `duration-200`

### Image Optimization
- Always use Next.js `<Image>` component from `next/image`
- Provide explicit `width` and `height` or use `fill` with a sized container
- Use appropriate `sizes` attribute for responsive images
- Set `priority` for above-the-fold images, `loading="lazy"` for others

### Bundle Size
- Avoid importing entire libraries; use tree-shakeable imports
- Dynamic import heavy components: `const Component = dynamic(() => import('./Component'))`

---

## ADA Compliance Rules (WCAG 2.1 AA)

### 1. Perceivable

#### 1.1.1 Non-text Content
- All `<img>` and `<Image>` MUST have `alt` attribute
- Meaningful images: descriptive alt text explaining content/purpose
- Decorative images: use `alt=""` with `aria-hidden="true"` or `role="presentation"`
- Complex images (charts): provide detailed description via `aria-describedby`

#### 1.2 Time-based Media
- Videos with audio MUST have captions
- Provide audio descriptions for important visual content
- ReactPlayer: configure tracks for captions

#### 1.4.3 Color Contrast
- Normal text: minimum 4.5:1 contrast ratio
- Large text (18px+ or 14px+ bold): minimum 3:1 ratio
- UI components/graphics: minimum 3:1 ratio
- Never convey information by color alone

#### 1.4.4 Resize Text
- Use rem/em units, not px for fonts
- Text must be resizable to 200% without loss of functionality

### 2. Operable

#### 2.1.1 Keyboard
- All functionality accessible via keyboard
- No keyboard traps
- Use semantic elements: `<button>`, `<a>`, `<input>`
- If using `onClick` on div/span, add `onKeyDown` and `role="button"` + `tabIndex={0}`

#### 2.4.1 Bypass Blocks
- Include skip navigation link in layout: `<a href="#main" className="sr-only focus:not-sr-only">Skip to content</a>`
- Use `<main id="main">` landmark

#### 2.4.4 Link Purpose
- Use descriptive link text (avoid "click here", "read more")
- Icon-only links need `aria-label`

#### 2.4.7 Focus Visible
- ALL interactive elements MUST have visible focus states
- Required pattern: `focus:outline-none focus:ring-2 focus:ring-purple-border focus:ring-offset-2`
- Use `focus-visible:` for keyboard-only focus styles

### 3. Understandable

#### 3.1.1 Language
- `<html lang="en">` required on root layout

#### 3.3.1 Error Identification
- Form errors must be clearly identified
- Use `aria-invalid="true"` and `aria-describedby` for error messages

#### 3.3.2 Labels
- All inputs MUST have labels via `<label htmlFor>`, `aria-label`, or `aria-labelledby`
- Placeholders are NOT sufficient as labels

### 4. Robust

#### 4.1.2 Name, Role, Value
- Interactive elements need accessible names
- Icon-only buttons: `<button aria-label="Close menu">`
- Custom components: proper ARIA roles and states
- If `aria-hidden="true"` on focusable element, add `tabIndex={-1}`

---

## SEO Best Practices

### Metadata (Next.js App Router)
- Every page MUST export `metadata` or `generateMetadata`
- Required fields: `title`, `description`
- Include `openGraph` and `twitter` for social sharing
- Add `alternates.canonical` for canonical URLs

```jsx
export const metadata = {
  title: 'Page Title | Vasion',
  description: 'Page description for search results',
  openGraph: {
    title: 'Page Title',
    description: 'Description for social sharing',
    images: ['/og-image.jpg'],
  },
  twitter: {
    card: 'summary_large_image',
  },
  alternates: {
    canonical: 'https://vasion.com/page-url',
  },
};
```

### Heading Hierarchy
- Every page MUST have exactly ONE `<h1>`
- Headings MUST follow logical order: h1 → h2 → h3 (never skip levels)
- Use headings for structure, not styling

### Semantic HTML
- Use landmarks: `<main>`, `<nav>`, `<header>`, `<footer>`, `<aside>`
- Use `<article>` for self-contained content
- Use `<section>` for thematic groupings (with heading)
- Avoid excessive div nesting ("div soup")

### Images
- ALL images need descriptive `alt` text
- Use Next.js `<Image>` for automatic optimization
- Include `width`, `height` or `fill` with `sizes`
- Use `priority` for above-fold images (LCP)

### Links
- Use descriptive anchor text (not "click here")
- External links: `target="_blank" rel="noopener noreferrer"`
- Internal links: use Next.js `<Link>` component

### Structured Data (JSON-LD)
- Add schema.org markup for rich search results
- Common types: Organization, Product, Article, FAQ, BreadcrumbList

### Required Files
- `public/robots.txt` - search engine instructions
- `public/sitemap.xml` - use next-sitemap for auto-generation
- `public/favicon.ico` - browser tab icon
- `app/opengraph-image.jpg` - social sharing fallback

---

## Code Quality Standards

### Import Organization
- ESLint with perfectionist plugin enforces import sorting
- Order: React/Next > external packages > internal aliases > relative imports
- Group imports with blank lines between groups

### Component Structure
```jsx
// 1. 'use client' directive (if needed)
'use client';

// 2. Imports (sorted by perfectionist)
import { useState } from 'react';
import Image from 'next/image';
import { cn } from '@/lib/cn';

// 3. Types/Interfaces (if TypeScript)

// 4. Component definition
export default function ComponentName({ prop1, prop2 }) {
  // 5. Hooks
  // 6. Handlers
  // 7. Render
  return (
    <div className={cn('base-classes', condition && 'conditional')}>
      {/* content */}
    </div>
  );
}
```

### Naming Conventions
- Components: PascalCase (`HeroSection.jsx`)
- Utilities/hooks: camelCase (`useMediaQuery.js`)
- CSS classes: kebab-case in Tailwind config

---

## IMPORTANT: Pure Tailwind Only

**NEVER use inline styles or scoped `<style>` tags.** Use only Tailwind classes.

### Converting VW to Tailwind

When different vw values per breakpoint target the SAME pixel size, use ONE Tailwind class:

```jsx
// Original styled-components (all target 24px):
padding: 1.5vw;        // Desktop: 1.5 × 1600/100 = 24px
padding: 2.344vw;      // Tablet: 2.344 × 1024/100 = 24px  
padding: 5vw;          // Mobile: 5 × 480/100 = 24px

// Converted: ONE Tailwind class
className="py-6" // 24px / 4 = 6
```

### Theme-Based Styling

Map theme props to Tailwind classes using conditional logic:

```jsx
const getCardBgClass = () => {
  if (isTransparent) return 'bg-transparent';
  switch (theme) {
    case 'dark': return 'bg-purple-dark';
    case 'light': return 'bg-white';
    default: return 'bg-purple';
  }
};

const getTextClass = () => {
  switch (theme) {
    case 'light': return 'text-txt-primary';
    default: return 'text-white';
  }
};

<div className={cn('p-15 rounded-3xl', getCardBgClass(), getTextClass())}>
```

### Responsive Padding Pattern

Map offset_spacing prop to Tailwind classes:

```jsx
const getPaddingClasses = () => {
  const base = blok.offset_spacing;
  if (base === 'top') return 'pt-15 pb-0 tab:pt-10 mob:pt-15';
  if (base === 'bottom') return 'pt-0 pb-15 tab:pb-10 mob:pb-15';
  return 'py-15 tab:py-10 mob:py-15';
};

<section className={cn('flex w-full', getPaddingClasses())}>
```

### Lists

Use Tailwind's `list-none` class:

```jsx
<ul className="list-none m-0 p-0 flex gap-5">
  <li className="list-none flex-shrink-0">
```

---

## Migration Checklist

When converting a styled-component file to Tailwind:

### 0. Ask for Figma Reference (BEFORE starting)

**ALWAYS ask the user:**
> "Do you have a Figma link for this component? I can use it to ensure pixel-perfect implementation."

If a Figma link is provided:
- Use the **Figma MCP tools** to fetch design specifications
- Extract exact values: colors, spacing, typography, dimensions, border-radius
- Compare converted component against Figma design
- Verify responsive breakpoints match design specs

### 1. Analyze Component Requirements
1. [ ] **Can this be a Server Component?** - Check for hooks, browser APIs, client libraries
2. [ ] If client-only code exists (GSAP, etc.), plan to extract it to minimal client component

### 2. Convert Structure
3. [ ] Remove styled-components imports
4. [ ] **Preserve EXACT container structure** - same number of wrappers, same nesting
5. [ ] **Handle ALL original props** - check for `transparent_background`, `offset_spacing`, `section_spacing`, etc.
6. [ ] Replace styled components with native elements + Tailwind classes or inline styles

### 3. Handle Styling
7. [ ] Convert dynamic styles (props) to conditional Tailwind classes using `cn()`
8. [ ] Calculate values for EACH breakpoint - vw→px→Tailwind (px / 4)
9. [ ] Use Tailwind breakpoint prefixes: `mob:`, `tab:`, `desk:`, `fw:`
10. [ ] Map theme values to Tailwind classes using helper functions
11. [ ] Add `list-none` class to all ul/li elements
12. [ ] **NEVER use inline styles or scoped `<style>` tags**

### 4. Extract Client Logic (if needed)
13. [ ] Move GSAP/animation code to `CarouselAnimator` or similar minimal client component
14. [ ] Conditionally render client component only when needed (e.g., `{shouldAnimate && <CarouselAnimator />}`)
15. [ ] Remove `'use client'` directive from main component if no longer needed

### 5. Validate
16. [ ] Verify ADA compliance (alt text, focus states, contrast)
17. [ ] Check heading hierarchy and semantic structure
18. [ ] **Test ALL breakpoints**: desktop, tablet, mobile - must match original exactly
19. [ ] Remove unused styled-component definitions
20. [ ] Remove debug console.log statements
21. [ ] Run `npm run checks` to validate compliance
