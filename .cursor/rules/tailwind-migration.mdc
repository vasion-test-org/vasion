---
description: Guidelines for Tailwind CSS v4 migration and maintaining code quality standards
globs: ["**/*.{js,jsx,ts,tsx}"]
alwaysApply: true
---

# Tailwind CSS v4 Migration Guidelines

This project uses **Tailwind CSS v4** with CSS-based configuration. We are migrating from styled-components for improved performance. Follow these rules when creating or modifying components.

## Tailwind v4 Configuration

Design tokens are defined in `app/globals.css` using the `@theme` directive:

```css
@import "tailwindcss";

@theme {
  --color-purple: #3D2562;
  --color-orange: #ff5100;
  --spacing-15: 3.75rem;
  --breakpoint-sm: 480px;
  /* All custom values defined here */
}
```

**Key v4 differences:**
- Use `@import "tailwindcss"` (not `@tailwind base/components/utilities`)
- Define custom values in `@theme` block (not `tailwind.config.js`)
- Colors use `--color-*`, spacing uses `--spacing-*`, breakpoints use `--breakpoint-*`
- Custom utility classes use `@utility` directive

### Custom Utility Classes with @utility

For custom backgrounds, gradients, or complex styles that can't be expressed as single values:

```css
/* app/globals.css */
@utility bg-footer {
  background: linear-gradient(180deg, #201435 52%, rgba(32, 20, 53, 0) 100%), 
              linear-gradient(270deg, #cc4800 1.74%, #5f47a8 99.26%), #201435;
}

@utility bg-purple-gradient {
  background: var(--gradient-purple);
}
```

**When to use @utility:**
- Custom gradients (multi-layer backgrounds)
- Complex backgrounds that need multiple CSS properties
- Any reusable style pattern

## BEFORE STARTING: Ask for Figma Link

**ALWAYS ask before creating or converting ANY component:**

> "Do you have a Figma MCP link for this component? I can use it to ensure pixel-perfect implementation."

Wait for response before proceeding. Use Figma MCP tools if link is provided.

---

## CRITICAL: Preserve Exact Structure AND Behavior

**Never add, remove, or rearrange containers during conversion.**
**Never simplify or "improve" the layout logic. Match the original exactly.**

### Rules:
1. **Preserve exact HTML structure** - Same containers, same nesting order
2. **Preserve exact behavior per breakpoint** - If desktop uses margin and fullWidth uses fixed width + centering, convert BOTH approaches exactly
3. **Never simplify** - Even if CSS seems redundant or could be "cleaner", match the original
4. **Each breakpoint is independent** - Different breakpoints may have completely different layout logic; preserve ALL of it

### Conversion Process (Element by Element):
1. Count all containers in the original component
2. Start at outermost container
3. Read its styled-component CSS **for ALL breakpoints**
4. Convert CSS properties to equivalent Tailwind classes **for each breakpoint separately**
5. Move to next nested child
6. Repeat until all elements converted
7. Verify final container count matches original
8. Verify behavior matches at EACH breakpoint (desktop, tablet, mobile, fullWidth)

### Example - CORRECT Structure:
```jsx
// Original: 3 containers
const Wrapper = styled.section`padding: 60px;`;
const Container = styled.div`max-width: 1304px; margin: 0 auto;`;
const Inner = styled.div`display: flex; gap: 40px;`;

// CORRECT: Still 3 containers
<section className="p-15">
  <div className="max-w-326 mx-auto">
    <div className="flex gap-10">
```

### Example - CORRECT Behavior Preservation:
```jsx
// Original: Different layout approach at fullWidth vs desktop
const LegalDiv = styled.div`
  margin: 0 10.278vw;           /* Desktop: uses margin for spacing */
  ${media.fullWidth} {
    width: 1244px;              /* FullWidth: uses fixed width instead */
    align-self: center;         /* FullWidth: uses centering */
  }
`;

// CORRECT: Preserve BOTH approaches exactly
<div className="mx-41 xl:mx-0 xl:w-311 xl:self-center">

// ❌ WRONG: Simplified to just one approach
<div className="max-w-311 mx-auto">  /* Lost the margin-based desktop behavior! */
```

### Example - WRONG Structure:
```jsx
// ❌ WRONG: Merged Container into section (now only 2 containers)
<section className="p-15 max-w-326 mx-auto">
  <div className="flex gap-10">

// ❌ WRONG: Added extra div (now 4 containers)
<section className="p-15">
  <div className="extra-wrapper">
    <div className="max-w-326 mx-auto">
      <div className="flex gap-10">
```

## Preserve Visual Layout

When converting styled-components to Tailwind:
- **PRESERVE THE EXACT VISUAL LAYOUT** - The converted component must look identical
- **DO NOT ADJUST SPACING, SIZING, OR POSITIONING** unless explicitly asked
- Match the original values as closely as possible using Tailwind utilities
- If an exact match isn't possible, use the CLOSEST Tailwind value

## Converting VW Values

**Viewport widths for calculation:**
- Desktop (base): 1600px → multiply vw × 16
- Tablet (md): 1024px → multiply vw × 10.24
- Mobile (sm): 480px → multiply vw × 4.8
- FullWidth (xl): uses px values directly

### Key Insight
VW values may target the SAME or DIFFERENT pixel sizes. **Always calculate first, then decide.**

| Target | Desktop (1600px) | Tablet (1024px) | Mobile (480px) | Tailwind |
|--------|------------------|-----------------|----------------|----------|
| 200px | `12.5vw` | `19.531vw` | `41.667vw` | `w-50` |
| 100px | `6.25vw` | `9.766vw` | `20.833vw` | `w-25` |
| 80px | `5vw` | `7.813vw` | `16.667vw` | `w-20` |
| 40px | `2.5vw` | `3.906vw` | `8.333vw` | `w-10` |

### Conversion Formula
```
px = vw × (viewportWidth / 100)
rem = px / 16
```

### How to Convert
1. **Identify the breakpoint** from the media query context
2. **Calculate px** using that breakpoint's viewport width
3. **Convert to rem** (px / 16)
4. **Find closest Tailwind** value

### Example: Converting styled-components
```jsx
// Original:
const Box = styled.div`
  width: 12.5vw; // Desktop (1600px): 12.5 × 16 = 200px = 12.5rem
  ${media.tablet} {
    width: 19.531vw; // Tablet (1024px): 19.531 × 10.24 = 200px = 12.5rem
  }
  ${media.mobile} {
    width: 41.667vw; // Mobile (480px): 41.667 × 4.8 = 200px = 12.5rem
  }
`;

// Converted: All breakpoints produce 200px, so use ONE Tailwind class:
<div className="w-50" /> // 12.5rem = 200px at all breakpoints
```

### Use Conversion Utility
```typescript
import { vwToRem, vwToPx, detectBreakpoint } from '@/lib/tailwind-utils';

// Convert vw at specific breakpoint
vwToRem(12.5, 1600) // Desktop: 12.5rem (200px)
vwToRem(19.531, 1024) // Tablet: 12.5rem (200px)
vwToRem(41.667, 480) // Mobile: 12.5rem (200px)

// All produce same result → use w-50
```

---

## Styling Rules

### Use Tailwind Utility Classes
- **NEVER** use arbitrary values like `w-[450px]`, `h-[200px]`, or `w-[9.5rem]`
- **ALWAYS** convert px to Tailwind number: `px / 4 = Tailwind class`
- Tailwind JIT auto-generates any number (e.g., `w-326` = 326 × 0.25rem = 1304px)
- Custom design tokens are defined in `@theme` block in `app/globals.css`

### PX to Tailwind Conversion
```
px / 4 = Tailwind number
```
Examples:
- 1304px → `w-326` (1304 / 4 = 326)
- 200px → `w-50` (200 / 4 = 50)
- 100px → `w-25` (100 / 4 = 25)
- 24px → `p-6` (24 / 4 = 6)

### Responsive Design
- Use project breakpoint prefixes: `sm:`, `md:`, `lg:`, `xl:`
- Write base styles, then override for specific breakpoints
- Example: `text-body-sm md:text-body-md lg:text-body-lg`

### Design Tokens
- Use colors from the config: `text-purple`, `bg-teal-500`, etc. (DEFAULT accessed without suffix)
- Use typography classes: `text-h1`, `text-body-lg`, `text-eyebrow`
- Use spacing tokens: `p-4`, `gap-6`, `m-8` (avoid arbitrary values)

### Conditional Classes
- Use the `cn()` utility from `@/lib/cn` for conditional class merging
- Import: `import { cn } from '@/lib/cn'`
- Example: `className={cn('base-classes', condition && 'conditional-class')}`

### Variant Groups with `tw` (Tagged Template)
- Use the `tw` utility from `@/lib/cn` to group classes by breakpoint/variant
- Import: `import { tw } from '@/lib/cn'`
- Reduces repetition: `sm:(px-7 pt-11 pb-17)` instead of `sm:px-7 sm:pt-11 sm:pb-17`

```jsx
// Group by breakpoint
className={tw`flex gap-4 md:(flex-row gap-6) lg:(gap-8 p-10)`}

// Group by state
className={tw`bg-white hover:(bg-purple text-white) focus:(ring-2 outline-none)`}

// Mix tw() inside clsx() for conditionals
className={clsx(
  tw`flex md:(flex-row gap-6)`,
  isActive && 'bg-purple'
)}
```

### Component Variants (CVA)
- Use `cva()` from `@/lib/cva` for components with multiple variant dimensions
- Import: `import { cva, type VariantProps } from '@/lib/cva'`
- Use CVA when a component has multiple props that affect styling (size, color, state)
- Combine with cn() for className overrides: `cn(variants({ size }), className)`

### Gradients
- Use CSS custom property backgrounds: `bg-purple-gradient`, `bg-orange-gradient`
- Available gradients: `purple-orbital`, `purple-gradient`, `orange-gradient`, `grey-gradient`, `light-purple`, `dark-purple`, `medium-purple`

---

## Performance Rules

### Server vs Client Components (CRITICAL)

**Server Components are the default and preferred choice** for performance.

#### Benefits of Server Components
- Zero client-side JavaScript for static content
- Faster initial page load
- Better SEO (content available immediately)
- Reduced bundle size

#### When to Use Server Components (Default)
- Rendering static content
- Displaying data from CMS (Storyblok)
- Layout containers and wrappers
- Components without interactivity

#### When Client Components Are Required
- React hooks: `useState`, `useEffect`, `useContext`, `useRef`
- Browser APIs: `window`, `document`, `localStorage`
- Event handlers that modify component state
- Third-party client libraries: GSAP, Swiper, etc.

### Extracting Client Logic Pattern

**ALWAYS extract client-only code into minimal client components**:

```jsx
// MyComponent.js - Server Component (NO 'use client')
import Image from 'next/image';
import CarouselAnimator from '@/components/CarouselAnimator';
import { defaultTheme, darkTheme, lightTheme } from '@/styles/theme';

// Static theme lookup - no hooks needed
const themes = { default: defaultTheme, dark: darkTheme, light: lightTheme };

const MyComponent = ({ blok }) => {
  const theme = themes[blok.theme] || themes.default;
  const shouldAnimate = blok.items?.length > 5;
  
  return (
    <>
      {/* All static content renders on server */}
      <section style={{ background: theme.myComponent.bg }}>
        <ul className="item-list">
          {blok.items?.map((item) => (
            <li key={item._uid} className="item">
              <Image src={item.image.filename} alt={item.alt} />
            </li>
          ))}
        </ul>
      </section>
      
      {/* Minimal client component - animation only */}
      {shouldAnimate && <CarouselAnimator selector=".item" />}
    </>
  );
};

export default MyComponent;
```

### Reusable CarouselAnimator

Use `CarouselAnimator` for any horizontal loop animation instead of creating new client components:

```jsx
import CarouselAnimator from '@/components/CarouselAnimator';

// Basic infinite scroll
<CarouselAnimator selector=".logo-item" />

// With custom options
<CarouselAnimator 
  selector=".testimonial-card"
  options={{
    speed: 0.5,        // Slower animation
    reversed: true,    // Right to left
    draggable: true,   // Enable drag
    paused: true,      // Start paused
  }}
  onChange={(el, index) => console.log('Active:', index)}
/>
```

### Styling Performance
- **NEVER use inline styles** - use Tailwind classes exclusively
- **NEVER use scoped `<style>` tags** - use Tailwind breakpoint prefixes
- Do not import styled-components in new code
- Use Tailwind's built-in transitions: `transition-colors`, `duration-200`

### Image Optimization
- Always use Next.js `<Image>` component from `next/image`
- Provide explicit `width` and `height` or use `fill` with a sized container
- Use appropriate `sizes` attribute for responsive images
- Set `priority` for above-the-fold images, `loading="lazy"` for others

### Bundle Size
- Avoid importing entire libraries; use tree-shakeable imports
- Dynamic import heavy components: `const Component = dynamic(() => import('./Component'))`

---

## ADA Compliance Rules (WCAG 2.1 AA)

### 1. Perceivable

#### 1.1.1 Non-text Content
- All `<img>` and `<Image>` MUST have `alt` attribute
- Meaningful images: descriptive alt text explaining content/purpose
- Decorative images: use `alt=""` with `aria-hidden="true"` or `role="presentation"`
- Complex images (charts): provide detailed description via `aria-describedby`

#### 1.2 Time-based Media
- Videos with audio MUST have captions
- Provide audio descriptions for important visual content
- ReactPlayer: configure tracks for captions

#### 1.4.3 Color Contrast
- Normal text: minimum 4.5:1 contrast ratio
- Large text (18px+ or 14px+ bold): minimum 3:1 ratio
- UI components/graphics: minimum 3:1 ratio
- Never convey information by color alone

#### 1.4.4 Resize Text
- Use rem/em units, not px for fonts
- Text must be resizable to 200% without loss of functionality

### 2. Operable

#### 2.1.1 Keyboard
- All functionality accessible via keyboard
- No keyboard traps
- Use semantic elements: `<button>`, `<a>`, `<input>`
- If using `onClick` on div/span, add `onKeyDown` and `role="button"` + `tabIndex={0}`

#### 2.4.1 Bypass Blocks
- Include skip navigation link in layout: `<a href="#main" className="sr-only focus:not-sr-only">Skip to content</a>`
- Use `<main id="main">` landmark

#### 2.4.4 Link Purpose
- Use descriptive link text (avoid "click here", "read more")
- Icon-only links need `aria-label`

#### 2.4.7 Focus Visible
- ALL interactive elements MUST have visible focus states
- Required pattern: `focus:outline-none focus:ring-2 focus:ring-purple-border focus:ring-offset-2`
- Use `focus-visible:` for keyboard-only focus styles

### 3. Understandable

#### 3.1.1 Language
- `<html lang="en">` required on root layout

#### 3.3.1 Error Identification
- Form errors must be clearly identified
- Use `aria-invalid="true"` and `aria-describedby` for error messages

#### 3.3.2 Labels
- All inputs MUST have labels via `<label htmlFor>`, `aria-label`, or `aria-labelledby`
- Placeholders are NOT sufficient as labels

### 4. Robust

#### 4.1.2 Name, Role, Value
- Interactive elements need accessible names
- Icon-only buttons: `<button aria-label="Close menu">`
- Custom components: proper ARIA roles and states
- If `aria-hidden="true"` on focusable element, add `tabIndex={-1}`

---

## SEO Best Practices

### Metadata (Next.js App Router)
- Every page MUST export `metadata` or `generateMetadata`
- Required fields: `title`, `description`
- Include `openGraph` and `twitter` for social sharing
- Add `alternates.canonical` for canonical URLs

```jsx
export const metadata = {
  title: 'Page Title | Vasion',
  description: 'Page description for search results',
  openGraph: {
    title: 'Page Title',
    description: 'Description for social sharing',
    images: ['/og-image.jpg'],
  },
  twitter: {
    card: 'summary_large_image',
  },
  alternates: {
    canonical: 'https://vasion.com/page-url',
  },
};
```

### Heading Hierarchy
- Every page MUST have exactly ONE `<h1>`
- Headings MUST follow logical order: h1 → h2 → h3 (never skip levels)
- Use headings for structure, not styling

### Semantic HTML
- Use landmarks: `<main>`, `<nav>`, `<header>`, `<footer>`, `<aside>`
- Use `<article>` for self-contained content
- Use `<section>` for thematic groupings (with heading)
- Avoid excessive div nesting ("div soup")

### Images
- ALL images need descriptive `alt` text
- Use Next.js `<Image>` for automatic optimization
- Include `width`, `height` or `fill` with `sizes`
- Use `priority` for above-fold images (LCP)

### Links
- Use descriptive anchor text (not "click here")
- External links: `target="_blank" rel="noopener noreferrer"`
- Internal links: use Next.js `<Link>` component

### Structured Data (JSON-LD)
- Add schema.org markup for rich search results
- Common types: Organization, Product, Article, FAQ, BreadcrumbList

### Required Files
- `public/robots.txt` - search engine instructions
- `public/sitemap.xml` - use next-sitemap for auto-generation
- `public/favicon.ico` - browser tab icon
- `app/opengraph-image.jpg` - social sharing fallback

---

## Code Quality Standards

### Import Organization
- ESLint with perfectionist plugin enforces import sorting
- Order: React/Next > external packages > internal aliases > relative imports
- Group imports with blank lines between groups

### Component Structure
```jsx
// 1. 'use client' directive (if needed)
'use client';

// 2. Imports (sorted by perfectionist)
import { useState } from 'react';
import Image from 'next/image';
import { cn } from '@/lib/cn';

// 3. Types/Interfaces (if TypeScript)

// 4. Component definition
export default function ComponentName({ prop1, prop2 }) {
  // 5. Hooks
  // 6. Handlers
  // 7. Render
  return (
    <div className={cn('base-classes', condition && 'conditional')}>
      {/* content */}
    </div>
  );
}
```

### Naming Conventions
- Components: PascalCase (`HeroSection.jsx`)
- Utilities/hooks: camelCase (`useMediaQuery.js`)
- CSS classes: kebab-case in Tailwind config

---

## IMPORTANT: Pure Tailwind Only

**NEVER use inline styles or scoped `<style>` tags.** Use only Tailwind classes.

### Mobile-First Responsive Pattern (CRITICAL)

**Always use mobile-first approach with standard Tailwind breakpoints:**

```jsx
// ✅ CORRECT: Mobile-first (base = mobile, sm: = larger screens)
className="px-4 sm:px-10"  // 16px on mobile, 40px at 481px+

// ❌ WRONG: Desktop-first approach
className="px-10 sm:px-4"
```

**Standard Tailwind v4 breakpoints (min-width based):**
- `sm:` → 640px and up
- `md:` → 768px and up  
- `lg:` → 1024px and up
- `xl:` → 1280px and up

### Centering Elements with Max-Width (CRITICAL)

**ALWAYS add `mx-auto` when using `max-w-*` to center content:**

```jsx
// ✅ CORRECT: Centered card with max-width
<div className="w-full max-w-326 mx-auto">

// ❌ WRONG: Missing mx-auto - card will be left-aligned
<div className="w-full max-w-326">
```

### Converting VW to Tailwind

**Step 1:** Calculate px for EACH breakpoint
**Step 2:** Check if results are SAME or DIFFERENT
**Step 3:** Apply appropriate Tailwind classes

```jsx
// Case A: All breakpoints target SAME px → ONE class
// Desktop: 1.5vw × 16 = 24px
// Tablet: 2.344vw × 10.24 = 24px  
// Mobile: 5vw × 4.8 = 24px
// All = 24px / 4 = 6 → py-6
className="py-6"

// Case B: Breakpoints target DIFFERENT px → SEPARATE classes
// Desktop: 88.806vw × 16 = 1421px / 4 = 355 → h-355 (base)
// FullWidth (xl): 1279px / 4 = 320 → xl:h-320
// Tablet (md): 124.902vw × 10.24 = 1279px / 4 = 320 → md:h-320
// Mobile (sm): 353.738vw × 4.8 = 1698px / 4 = 425 → sm:h-425
className="h-355 xl:h-320 md:h-320 sm:h-425"
```

### Theme-Based Styling with Inline Conditionals

Use ternary operators directly in `clsx()` for cleaner, more readable code:

```jsx
import clsx from 'clsx';

<div
  className={clsx(
    // CRITICAL: mx-auto for centering
    'w-full overflow-hidden mx-auto',
    // Background - inline ternary chain
    isTransparent ? 'bg-transparent' : theme === 'dark' ? 'bg-purple-dark' : 'bg-purple',
    // Text color
    theme === 'light' ? 'text-txt-primary' : 'text-white',
    // Max width - conditional
    isTransparent ? 'max-w-full' : 'max-w-326',
    // Padding
    'p-15 sm:p-10',
    // Border radius
    'rounded-3xl'
  )}
>
```

### Responsive Padding Based on Props

Map offset_spacing prop to Tailwind classes with mobile-first approach:

```jsx
<section
  className={clsx(
    'flex w-full items-center justify-center',
    // Mobile-first horizontal padding
    'px-4 sm:px-10',
    // Vertical padding based on offset_spacing prop
    offsetSpacing === 'top' && 'pt-15 pb-0',
    offsetSpacing === 'bottom' && 'pt-0 pb-15',
    !offsetSpacing && 'py-15'
  )}
>
```

### Lists

Use Tailwind's `list-none` class on both ul and li:

```jsx
<ul className="list-none m-0 p-0 flex gap-5">
  <li className="list-none flex-shrink-0">
```

---

## Migration Checklist

When converting a styled-component file to Tailwind:

### 0. Ask for Figma Reference (BEFORE starting)

**ALWAYS ask the user:**
> "Do you have a Figma link for this component? I can use it to ensure pixel-perfect implementation."

If a Figma link is provided:
- Use the **Figma MCP tools** to fetch design specifications
- Extract exact values: colors, spacing, typography, dimensions, border-radius
- Compare converted component against Figma design
- Verify responsive breakpoints match design specs

### 1. Analyze Component Requirements
1. [ ] **Can this be a Server Component?** - Check for hooks, browser APIs, client libraries
2. [ ] If client-only code exists (GSAP, etc.), plan to extract it to minimal client component

### 2. Convert Structure (Element by Element)
3. [ ] **Count containers FIRST** - Note exactly how many wrapper elements exist in original
4. [ ] Remove styled-components imports
5. [ ] **Convert outermost container** - read its CSS, convert to Tailwind classes
6. [ ] **Move to next nested child** - repeat the process
7. [ ] **Continue until all elements converted** - never skip or merge containers
8. [ ] **Handle ALL original props** - check for `transparent_background`, `offset_spacing`, `section_spacing`, etc.
9. [ ] **Verify container count matches original** - must be exactly the same

### 3. Handle Styling
10. [ ] Convert dynamic styles (props) to conditional Tailwind classes using `clsx()`
11. [ ] **Calculate vw→px for EACH breakpoint separately:**
    - Desktop: vw × 16 = px
    - Tablet: vw × 10.24 = px
    - Mobile: vw × 4.8 = px
    - Then: px / 4 = Tailwind number
12. [ ] **Check if px values are SAME or DIFFERENT** - use ONE class if same, SEPARATE classes if different
13. [ ] **Use breakpoint prefixes**: `sm:` (mobile), `md:` (tablet), `lg:` (desktop), `xl:` (fullWidth)
13. [ ] **Add `mx-auto` when using `max-w-*`** to center content
14. [ ] Use inline ternary operators in `clsx()` for theme-based styling
15. [ ] Add `list-none` class to all ul/li elements
16. [ ] **NEVER use inline styles or scoped `<style>` tags**

### 4. Extract Client Logic (if needed)
17. [ ] Move GSAP/animation code to `CarouselAnimator` or similar minimal client component
18. [ ] Conditionally render client component only when needed (e.g., `{shouldAnimate && <CarouselAnimator />}`)
19. [ ] Remove `'use client'` directive from main component if no longer needed

### 5. Validate
20. [ ] Verify ADA compliance (alt text, focus states, contrast)
21. [ ] Check heading hierarchy and semantic structure
22. [ ] **Test ALL breakpoints**: desktop, tablet, mobile - must match original exactly
23. [ ] **Verify final container count** - must match original exactly
24. [ ] Remove unused styled-component definitions
25. [ ] Remove debug console.log statements
26. [ ] Run `npm run checks` to validate compliance
27. [ ] **Clear browser cache** - Hard refresh (Cmd+Shift+R) or use incognito window to see changes
