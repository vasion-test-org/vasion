---
description: Guidelines for Tailwind CSS migration and maintaining code quality standards
globs: ["**/*.{js,jsx,ts,tsx}"]
alwaysApply: true
---

# Tailwind CSS Migration Guidelines

This project is migrating from styled-components to Tailwind CSS for improved performance. Follow these rules when creating or modifying components.

## CRITICAL: Preserve Original Layout

When converting styled-components to Tailwind:
- **PRESERVE THE EXACT VISUAL LAYOUT** - The converted component must look identical
- **DO NOT ADJUST SPACING, SIZING, OR POSITIONING** unless explicitly asked
- Match the original values as closely as possible using Tailwind utilities
- If an exact match isn't possible, use the CLOSEST Tailwind value

## Converting VW Values

Based on [pxvwconverter](https://github.com/RJWadley/pxvwconverter) - the **same pixel value** requires **different vw values** at each breakpoint.

### Key Insight
When styled-components use different vw values per breakpoint, they're targeting the **same pixel size**:

| Target | Desktop (1600px) | Tablet (1024px) | Mobile (480px) | Tailwind |
|--------|------------------|-----------------|----------------|----------|
| 200px | `12.5vw` | `19.531vw` | `41.667vw` | `w-50` |
| 100px | `6.25vw` | `9.766vw` | `20.833vw` | `w-25` |
| 80px | `5vw` | `7.813vw` | `16.667vw` | `w-20` |
| 40px | `2.5vw` | `3.906vw` | `8.333vw` | `w-10` |

### Conversion Formula
```
px = vw × (viewportWidth / 100)
rem = px / 16
```

### How to Convert
1. **Identify the breakpoint** from the media query context
2. **Calculate px** using that breakpoint's viewport width
3. **Convert to rem** (px / 16)
4. **Find closest Tailwind** value

### Example: Converting styled-components
```jsx
// Original:
const Box = styled.div`
  width: 12.5vw; // Desktop (1600px): 12.5 × 16 = 200px = 12.5rem
  ${media.tablet} {
    width: 19.531vw; // Tablet (1024px): 19.531 × 10.24 = 200px = 12.5rem
  }
  ${media.mobile} {
    width: 41.667vw; // Mobile (480px): 41.667 × 4.8 = 200px = 12.5rem
  }
`;

// Converted: All breakpoints produce 200px, so use ONE Tailwind class:
<div className="w-50" /> // 12.5rem = 200px at all breakpoints
```

### Use Conversion Utility
```typescript
import { vwToRem, vwToPx, detectBreakpoint } from '@/lib/tailwind-utils';

// Convert vw at specific breakpoint
vwToRem(12.5, 1600) // Desktop: 12.5rem (200px)
vwToRem(19.531, 1024) // Tablet: 12.5rem (200px)
vwToRem(41.667, 480) // Mobile: 12.5rem (200px)

// All produce same result → use w-50
```

---

## Styling Rules

### Use Tailwind Utility Classes
- **NEVER** use arbitrary values like `w-[450px]`, `h-[200px]`, or `w-[9.5rem]`
- **ALWAYS** convert px to Tailwind number: `px / 4 = Tailwind class`
- Tailwind JIT auto-generates any number (e.g., `w-326` = 326 × 0.25rem = 1304px)
- **DO NOT add custom values to tailwind.config.js** - JIT handles it automatically

### PX to Tailwind Conversion
```
px / 4 = Tailwind number
```
Examples:
- 1304px → `w-326` (1304 / 4 = 326)
- 200px → `w-50` (200 / 4 = 50)
- 100px → `w-25` (100 / 4 = 25)
- 24px → `p-6` (24 / 4 = 6)

### Responsive Design
- Use project breakpoint prefixes: `mob:`, `tab:`, `desk:`, `fw:`
- Mobile-first is preferred: write base styles, then add larger breakpoint overrides
- Example: `text-body-sm tab:text-body-md desk:text-body-lg`

### Design Tokens
- Use colors from the config: `text-purple-DEFAULT`, `bg-teal-500`, etc.
- Use typography classes: `text-h1`, `text-body-lg`, `text-eyebrow`
- Use spacing tokens: `p-4`, `gap-6`, `m-8` (avoid arbitrary values)

### Conditional Classes
- Use the `cn()` utility from `@/lib/cn` for conditional class merging
- Import: `import { cn } from '@/lib/cn'`
- Example: `className={cn('base-classes', condition && 'conditional-class')}`

### Component Variants (CVA)
- Use `cva()` from `@/lib/cva` for components with multiple variant dimensions
- Import: `import { cva, type VariantProps } from '@/lib/cva'`
- Use CVA when a component has multiple props that affect styling (size, color, state)
- Combine with cn() for className overrides: `cn(variants({ size }), className)`

### Gradients
- Use CSS custom property backgrounds: `bg-purple-gradient`, `bg-orange-gradient`
- Available gradients: `purple-orbital`, `purple-gradient`, `orange-gradient`, `grey-gradient`, `light-purple`, `dark-purple`, `medium-purple`

---

## Performance Rules

### Server vs Client Components (CRITICAL)

**Server Components are the default and preferred choice** for performance.

#### Benefits of Server Components
- Zero client-side JavaScript for static content
- Faster initial page load
- Better SEO (content available immediately)
- Reduced bundle size

#### When to Use Server Components (Default)
- Rendering static content
- Displaying data from CMS (Storyblok)
- Layout containers and wrappers
- Components without interactivity

#### When Client Components Are Required
- React hooks: `useState`, `useEffect`, `useContext`, `useRef`
- Browser APIs: `window`, `document`, `localStorage`
- Event handlers that modify component state
- Third-party client libraries: GSAP, Swiper, etc.

### Extracting Client Logic Pattern

**ALWAYS extract client-only code into minimal client components**:

```jsx
// MyComponent.js - Server Component (NO 'use client')
import Image from 'next/image';
import CarouselAnimator from '@/components/CarouselAnimator';
import { defaultTheme, darkTheme, lightTheme } from '@/styles/theme';

// Static theme lookup - no hooks needed
const themes = { default: defaultTheme, dark: darkTheme, light: lightTheme };

const MyComponent = ({ blok }) => {
  const theme = themes[blok.theme] || themes.default;
  const shouldAnimate = blok.items?.length > 5;
  
  return (
    <>
      {/* All static content renders on server */}
      <section style={{ background: theme.myComponent.bg }}>
        <ul className="item-list">
          {blok.items?.map((item) => (
            <li key={item._uid} className="item">
              <Image src={item.image.filename} alt={item.alt} />
            </li>
          ))}
        </ul>
      </section>
      
      {/* Minimal client component - animation only */}
      {shouldAnimate && <CarouselAnimator selector=".item" />}
    </>
  );
};

export default MyComponent;
```

### Reusable CarouselAnimator

Use `CarouselAnimator` for any horizontal loop animation instead of creating new client components:

```jsx
import CarouselAnimator from '@/components/CarouselAnimator';

// Basic infinite scroll
<CarouselAnimator selector=".logo-item" />

// With custom options
<CarouselAnimator 
  selector=".testimonial-card"
  options={{
    speed: 0.5,        // Slower animation
    reversed: true,    // Right to left
    draggable: true,   // Enable drag
    paused: true,      // Start paused
  }}
  onChange={(el, index) => console.log('Active:', index)}
/>
```

### Scoped CSS for Server Component Responsive Styles

Use inline `<style>` tags with unique component IDs for responsive styles without client JS:

```jsx
const componentId = `card-${blok._uid}`;

return (
  <>
    <style>{`
      .${componentId} {
        --card-bg: ${theme.card.bg};
        padding: 3.75rem;
        max-width: 81.5rem;
        border-radius: 1.5rem;
      }
      @media (max-width: 1024px) {
        .${componentId} {
          padding: 2.5rem;
          max-width: 100%;
        }
      }
      @media (max-width: 480px) {
        .${componentId} {
          padding: 1.75rem 1.125rem;
          border-radius: 1.7rem;
        }
      }
    `}</style>
    <div className={componentId} style={{ background: 'var(--card-bg)' }}>
      ...
    </div>
  </>
);
```

### Styling Performance
- Avoid inline styles; use Tailwind classes exclusively
- Do not import styled-components in new code
- Use Tailwind's built-in transitions: `transition-colors`, `duration-200`

### Image Optimization
- Always use Next.js `<Image>` component from `next/image`
- Provide explicit `width` and `height` or use `fill` with a sized container
- Use appropriate `sizes` attribute for responsive images
- Set `priority` for above-the-fold images, `loading="lazy"` for others

### Bundle Size
- Avoid importing entire libraries; use tree-shakeable imports
- Dynamic import heavy components: `const Component = dynamic(() => import('./Component'))`

---

## ADA Compliance Rules (WCAG 2.1 AA)

### 1. Perceivable

#### 1.1.1 Non-text Content
- All `<img>` and `<Image>` MUST have `alt` attribute
- Meaningful images: descriptive alt text explaining content/purpose
- Decorative images: use `alt=""` with `aria-hidden="true"` or `role="presentation"`
- Complex images (charts): provide detailed description via `aria-describedby`

#### 1.2 Time-based Media
- Videos with audio MUST have captions
- Provide audio descriptions for important visual content
- ReactPlayer: configure tracks for captions

#### 1.4.3 Color Contrast
- Normal text: minimum 4.5:1 contrast ratio
- Large text (18px+ or 14px+ bold): minimum 3:1 ratio
- UI components/graphics: minimum 3:1 ratio
- Never convey information by color alone

#### 1.4.4 Resize Text
- Use rem/em units, not px for fonts
- Text must be resizable to 200% without loss of functionality

### 2. Operable

#### 2.1.1 Keyboard
- All functionality accessible via keyboard
- No keyboard traps
- Use semantic elements: `<button>`, `<a>`, `<input>`
- If using `onClick` on div/span, add `onKeyDown` and `role="button"` + `tabIndex={0}`

#### 2.4.1 Bypass Blocks
- Include skip navigation link in layout: `<a href="#main" className="sr-only focus:not-sr-only">Skip to content</a>`
- Use `<main id="main">` landmark

#### 2.4.4 Link Purpose
- Use descriptive link text (avoid "click here", "read more")
- Icon-only links need `aria-label`

#### 2.4.7 Focus Visible
- ALL interactive elements MUST have visible focus states
- Required pattern: `focus:outline-none focus:ring-2 focus:ring-purple-border focus:ring-offset-2`
- Use `focus-visible:` for keyboard-only focus styles

### 3. Understandable

#### 3.1.1 Language
- `<html lang="en">` required on root layout

#### 3.3.1 Error Identification
- Form errors must be clearly identified
- Use `aria-invalid="true"` and `aria-describedby` for error messages

#### 3.3.2 Labels
- All inputs MUST have labels via `<label htmlFor>`, `aria-label`, or `aria-labelledby`
- Placeholders are NOT sufficient as labels

### 4. Robust

#### 4.1.2 Name, Role, Value
- Interactive elements need accessible names
- Icon-only buttons: `<button aria-label="Close menu">`
- Custom components: proper ARIA roles and states
- If `aria-hidden="true"` on focusable element, add `tabIndex={-1}`

---

## SEO Best Practices

### Metadata (Next.js App Router)
- Every page MUST export `metadata` or `generateMetadata`
- Required fields: `title`, `description`
- Include `openGraph` and `twitter` for social sharing
- Add `alternates.canonical` for canonical URLs

```jsx
export const metadata = {
  title: 'Page Title | Vasion',
  description: 'Page description for search results',
  openGraph: {
    title: 'Page Title',
    description: 'Description for social sharing',
    images: ['/og-image.jpg'],
  },
  twitter: {
    card: 'summary_large_image',
  },
  alternates: {
    canonical: 'https://vasion.com/page-url',
  },
};
```

### Heading Hierarchy
- Every page MUST have exactly ONE `<h1>`
- Headings MUST follow logical order: h1 → h2 → h3 (never skip levels)
- Use headings for structure, not styling

### Semantic HTML
- Use landmarks: `<main>`, `<nav>`, `<header>`, `<footer>`, `<aside>`
- Use `<article>` for self-contained content
- Use `<section>` for thematic groupings (with heading)
- Avoid excessive div nesting ("div soup")

### Images
- ALL images need descriptive `alt` text
- Use Next.js `<Image>` for automatic optimization
- Include `width`, `height` or `fill` with `sizes`
- Use `priority` for above-fold images (LCP)

### Links
- Use descriptive anchor text (not "click here")
- External links: `target="_blank" rel="noopener noreferrer"`
- Internal links: use Next.js `<Link>` component

### Structured Data (JSON-LD)
- Add schema.org markup for rich search results
- Common types: Organization, Product, Article, FAQ, BreadcrumbList

### Required Files
- `public/robots.txt` - search engine instructions
- `public/sitemap.xml` - use next-sitemap for auto-generation
- `public/favicon.ico` - browser tab icon
- `app/opengraph-image.jpg` - social sharing fallback

---

## Code Quality Standards

### Import Organization
- ESLint with perfectionist plugin enforces import sorting
- Order: React/Next > external packages > internal aliases > relative imports
- Group imports with blank lines between groups

### Component Structure
```jsx
// 1. 'use client' directive (if needed)
'use client';

// 2. Imports (sorted by perfectionist)
import { useState } from 'react';
import Image from 'next/image';
import { cn } from '@/lib/cn';

// 3. Types/Interfaces (if TypeScript)

// 4. Component definition
export default function ComponentName({ prop1, prop2 }) {
  // 5. Hooks
  // 6. Handlers
  // 7. Render
  return (
    <div className={cn('base-classes', condition && 'conditional')}>
      {/* content */}
    </div>
  );
}
```

### Naming Conventions
- Components: PascalCase (`HeroSection.jsx`)
- Utilities/hooks: camelCase (`useMediaQuery.js`)
- CSS classes: kebab-case in Tailwind config

---

## IMPORTANT: Inline Styles Fallback

**Tailwind JIT classes may not be applied** in some cases. When layout-critical styles aren't working:

### Use ScreenContext for Responsive Styles

Instead of Tailwind breakpoint prefixes, use `ScreenContext` for reliable responsive values:

```jsx
'use client';
import { useContext } from 'react';
import { ScreenContext } from '@/components/providers/Screen';

const MyComponent = () => {
  const screen = useContext(ScreenContext);
  
  // Responsive styles using screen context
  const getContainerStyle = () => {
    if (screen.mobile) {
      return { 
        padding: '2.8rem 1.8rem 4.2rem', // 45px 29px 67px
        borderRadius: '1.7rem', // 27px
      };
    } else if (screen.tablet) {
      return { 
        padding: '2.5rem 2.5rem 3.75rem', // 40px 40px 60px
        borderRadius: '1.5rem', // 24px
      };
    }
    // Desktop/Fullwidth
    return { 
      maxWidth: '81.5rem', // 1304px
      padding: '3.75rem', // 60px
      borderRadius: '1.5rem', // 24px
    };
  };
  
  return <div style={getContainerStyle()}>...</div>;
};
```

### Lists Always Need Inline Style

```jsx
<ul style={{ listStyle: 'none', margin: 0, padding: 0, display: 'flex', gap: '1.25rem' }}>
  <li style={{ listStyle: 'none', flexShrink: 0 }}>
```

### Section Wrapper Pattern

Most components have an outer wrapper for spacing between components:

```jsx
const getWrapperStyle = () => {
  const hasCustomSpacing = blok.section_spacing && blok.section_spacing !== 'default';
  
  let verticalSpacing = '3.75rem'; // 60px default
  let horizontalPadding = '0';
  
  if (screen.tablet) {
    verticalSpacing = '5.859vw';
    horizontalPadding = '2.5rem'; // 40px
  } else if (screen.mobile) {
    verticalSpacing = '12.5vw';
    horizontalPadding = '1rem'; // 16px
  }
  
  const spacing = hasCustomSpacing ? `${blok.section_spacing}px` : verticalSpacing;
  
  if (blok.offset_spacing === 'top') {
    return { paddingTop: spacing, paddingBottom: 0, paddingLeft: horizontalPadding, paddingRight: horizontalPadding };
  }
  if (blok.offset_spacing === 'bottom') {
    return { paddingTop: 0, paddingBottom: spacing, paddingLeft: horizontalPadding, paddingRight: horizontalPadding };
  }
  return { paddingTop: spacing, paddingBottom: spacing, paddingLeft: horizontalPadding, paddingRight: horizontalPadding };
};
```

---

## Migration Checklist

When converting a styled-component file to Tailwind:

### 0. Ask for Figma Reference (BEFORE starting)

**ALWAYS ask the user:**
> "Do you have a Figma link for this component? I can use it to ensure pixel-perfect implementation."

If a Figma link is provided:
- Use the **Figma MCP tools** to fetch design specifications
- Extract exact values: colors, spacing, typography, dimensions, border-radius
- Compare converted component against Figma design
- Verify responsive breakpoints match design specs

### 1. Analyze Component Requirements
1. [ ] **Can this be a Server Component?** - Check for hooks, browser APIs, client libraries
2. [ ] If client-only code exists (GSAP, etc.), plan to extract it to minimal client component

### 2. Convert Structure
3. [ ] Remove styled-components imports
4. [ ] **Preserve EXACT container structure** - same number of wrappers, same nesting
5. [ ] **Handle ALL original props** - check for `transparent_background`, `offset_spacing`, `section_spacing`, etc.
6. [ ] Replace styled components with native elements + Tailwind classes or inline styles

### 3. Handle Styling
7. [ ] Convert dynamic styles (props) to conditional classes using `cn()` or conditional inline styles
8. [ ] Calculate values for EACH breakpoint - vw→px→rem
9. [ ] For Server Components: Use scoped `<style>` tags with `@media` queries for responsive styles
10. [ ] For Client Components: Use `ScreenContext` when Tailwind breakpoint classes don't work
11. [ ] Replace theme values with static theme imports (Server) or theme context (Client)
12. [ ] Add `listStyle: 'none'` to all ul/li elements

### 4. Extract Client Logic (if needed)
13. [ ] Move GSAP/animation code to `CarouselAnimator` or similar minimal client component
14. [ ] Conditionally render client component only when needed (e.g., `{shouldAnimate && <CarouselAnimator />}`)
15. [ ] Remove `'use client'` directive from main component if no longer needed

### 5. Validate
16. [ ] Verify ADA compliance (alt text, focus states, contrast)
17. [ ] Check heading hierarchy and semantic structure
18. [ ] **Test ALL breakpoints**: desktop, tablet, mobile - must match original exactly
19. [ ] Remove unused styled-component definitions
20. [ ] Remove debug console.log statements
21. [ ] Run `npm run checks` to validate compliance
